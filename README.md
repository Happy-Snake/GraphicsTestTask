# Тестовое задание на позицию программиста компьютерной графики

## Двоичное представление

Задание: Напишите функцию, которая принимает на вход знаковое целове число и 
печатает его двоичное представление, не используя библиотечных классов или функций

Решение: В качестве решения было использовано объединение, в котором хранится само число и 
массив символов. Соответсвенно, каждый символ массива - бит числа

TODO: Реализовать обработку нажатия backspace при вводе числа 


## Сериализация/десериализация

Задание: Реализуйте функции сериализации и десериализации двусвязного списка в бинарном вормате в файл

Решение: Для перевода данных в бинарный формат был использован аналогичный прошлому методу подход, только 
с использованием шаблонов для перевода в бинарный формат данных различных типов. 

Формат записываемых данных: количество элементов списка, размер id элемента №1, id элемента №1, размер id rand-элемента №1, 
id rand-элемента №1, размер даных элемента №1, данные элемента №1, ..., размер id элемента №n, id элемента №n, 
размер id rand-элемента №n, id rand-элемента №n, размер даных элемента №n, данные элемента №n

В качестве id был использован адрес элемента.

TODO: Оптимизировать время доступа к элементу за счет двусвязности списка


## Нахождение нормали к вершине

Задание: Реализуйте функцию расчета усредненных нормалей меша, заданного индексируемыми треугольниками

Решение: В качестве нормали к вершине была взята сумма нормалей граней, содержащих эту вершину. Основная проблема, решаемая
в рамках задания - определение направление векторов нормали. Для корректного расчета номрали должы быть направлены вовне 
фигуры. 

Для определения направления нормали необходимо определить, сколько раз она пересечет другие грани этой фигуры: 
1) Если количество пересечений четное, значит изначально вектор смотрел вовне фигуры, однако на его пути возникали 
грани, при пересечении которых он "заходил в фигуру", после чего "выходил" из неё. 
2) Если количество пересечений нечетное, 
значит вектор изначально смотрел внутрь фигуры, и ему потребовалось один раз пересечь грань "на выход", чтобы попасть в состояение 1
3) Если количество пересечений равно 0, нормаль смотрит вовне 

На первом шаге для каждой грани необходимо определить, из какой точки должен брать начало вектор нормали. Чтобы эта точка не 
оказалась на ребре, возьмем координатами в качестве координат x,y центр вписанной в проекцию на Оxy окружности 
(TODO не предусмотрен вариант, когда прекция - линия, а не треугольник). Для найденных x,y вычислим z.

Далее проверим, направлен ли вектор нормали (nx, ny, nz), исходящий из точки (x0, y0, z0) в сторону плоскости (Ax + By + Cz + D = 0), 
содержащей проверяемый треугольник. Для этого решим уравнение: A(x0 + nx * t) + B(y0 + ny * t) + C(z0 + nx * t) + D = 0. Получим 
t =  -(Ax0 + By0 + Cz0 + D) / (A * nx + B * ny + C * nz). Если t < 0, вектор не пересекает плоскость, если t > 0 - пересекает.
Точка пересечения: (x0 + nx * t, y0 + ny * t, z0 + nz * t).

Осталось определить, находится ли точка внутри треугольника. Для этого с помощью векторного произведения посмотрим, 
лежит ли точка с по одну сторону (слева или справа) для каждой из сторон. Для этого знаки всех трех векторных произведений должны совпадать.

Осталось для каждой грани посчитать количество её пересечений с другими гранями, при необходимости, сменить знак нормали и посчитать сумму 
поучившихся нормалей.

TODO: 
1) Избавиться от цикла внутри цикла. В текущей версии для определения количества пересечений алгоритм для каждой грани проходит по
всем остальным граням. 
2) Предусмотреть частный случай, когда проекцией грани на Oxy является прямая, а не треугольник.
